## Для тех, кто еще не начал ничего сдавать и пока не понимает, что вообще сдавать и как вообще начать.

Перед нами большая проектная работа, которую надо сдать по результатам прохождения всего модуля. 
Что нужно обязательно учесть. Это ОДНА проектная работа. Она разделена на две части, но все равно это одна проектная работа и зачет по ней вы получите в конце 9-го спринта выполнив ее всю.

Первая часть сдается после 8-го спринта в соответствии с заданием в вашем тренажере. Это документация. Напомню, что UML схема НЕ обязательна, это опция, можете ее нарисовать, если есть желание. После того, как вы сдадите документацию, ревьювер вам напишет, что вы можете реализовывать функционал. Работа при этом НЕ БУДЕТ принята, так как это только часть Проектной Работы. Это нормально. Вы продолжаете изучать 9-й спринт и после этого продолжите сдавать проект в той-же самой форме. Если вы потратили 2 итерации, которые даются на сдачу документации, то вы все равно продолжаете изучение 9-го спринта и после него продолжаете сдавать ПР, но уже исправляя документацию и вместе с ней отправляя на проверку полностью все приложение.
Лучше сперва пройти теорию всего модуля и только потом, после просмотра всех видео и прочтения всех постов, после того, как вы разберетесь в том, как работает проект "Оно тебе надо", который дан вам в 9-м спринте, начинать выполнение проектной работы. С чего начать и как ее лучше выполнить.

Как говорится “Слона нужно есть по частям”
Предлагаю описать некоторые шаги, выполнение которых поможет вам пройти этот непростой этап.  Внутри треда я описал 5 основных шагов выполнения проектной работы, надеюсь, это поможет вам понять в каком направлении двигаться и с чего начинать.

## Часть первая.

Убедитесь, что у вас получен стартовый набор в вашей учетной записи на Гитхабе.
Скачайте и подключите коллекцию для программы Postman.

https://larek-api.nomoreparties.co/weblarek.postman.json

Убедитесь, что можете посмотреть примеры запросы и формат возвращаемых сервером данных.
По инструкции из задания к проектной работе создайте в корне своего проекта файл .env с константой, хранящей адрес сервера.
Скачайте из репозитория каноничное решение для проекта “Оно тебе надо”, который рассматривался в 9 спринте. Будем использовать его как пример для выполнения нашей работы.

Откройте макет проекта Веб-Ларек.
Посмотрите внимательно на макет и потом посмотрите на те данные, которые вам возвращает сервер на запросы (это в Постмане)
Сейчас ваша задача понять, какие данные нужно хранить в приложении и как эти данные могут изменяться, когда пользователь будет использовать наше приложение. Представьте все действия пользователя на сайте. Как при этих действиях будут изменяться данные. Например, если мы покупаем какой-то товар, то действие с данными будет такое: в корзине, которая представляет из себя массив объектов - товаров происходит добавление объекта в этот массив. И т.д.

Начните описывать Интерфейс для данных.
Т.е. вам нужно типизировать тот объект, который будет хранить эти данные.
Например карточка товара. (Чтобы понять какие типы у каких свойств в объектах с данными, подсматривайте в Постман)
Объекты для хранения данных не обязательно совпадают с теми, которые возвращает сервер. например, сервер не хранит и не отдает нам Корзину с нашими покупками.

Как пример, можно заглянуть и разобраться, как описаны данные в проекте “оно тебе надо”, например посмотрите интерфейс ILotItem
После написания Интерфейсов, посмотрите еще раз на макет и пройдитесь еще раз по всему пути, как пользователь. Смотрите при этом на описанные вами интерфейсы. Все ли данные вы учли в них.
Продолжение следует….

## Часть вторая.

Начинаем собирать нашу документацию.
Создайте в документации блок “Описание данных”
Перенесите в него уже написанные вами Интерфейсы, описывающие данные. напишите для чего они будут использоваться, что где хранится. Теперь наша задача продумать и описать модели данных.

Это Классы, которые будут отвечать за хранение данных. Может быть один класс, который будет хранить сразу все. Может быть несколько, например отдельно для товаров, отдельно для корзины и т.д.

Теперь возвращаемся к тем действиям, которые мы продумывали над нашими данными. Давайте их опишем. Заметьте, это пока еще не код. Только проектирование. Взяли конкретные данные. Посмотрим на примере нашего прошлого проекта Место.

У нас есть карточки. В первом шаге вы написали Интерфейс для данных. Там хранени данных карточки, ссылка, название, владелец, лайки и т.д. Вот теперь давайте думать о действиях. Согласно макету и нашим планам из прошлого шага мы можем что делать? Добавлять карточки. Начинаем описывать интерфейс для модели данных, которая будет хранить карточки и работать с ними. 

Что он хранит, массив карточек. Для карточки интерфейс уже описан в первом шаге, используем его для указания типа массива. Первое действие - добавление. Ага, значит добавим метод для добавления карточки. Это сеттер. Описали его в интерфейсе. Дальше, можно удалять карточки. Ок, добавили еще метод. Пока не касаемся реализации, просто описываем интерфейс.

Что еще? А изначально массив откуда берется? Мы его откуда-то получаем (все равно откуда) Добавили метод для добавления массива или инициализации. Здесь же еще нужно как-то хранить выбранную для чего-то карточку, например в Место это карточка для ее отображения в отдельном попапе. У вас карточка, открытая подробно в попапе.
И т.д.

После того, как все действия отражены в интефейсе, сделаем следующее. Пройдемся еще раз по всей логике по макету. Вот тут у нас должна отобразиться главная страница, что на ней, массив, он с сервера загружается. Есть у нас для этого запланированный метод, есть. Если пользователь нажмет плюсик, открывается попап новой карточки, данные меняются, нет еще. Потом после заполнения формы будет сабмит. При этом карточку надо будет после ответа сервера сохранить. Есть у нас для этого метод? Да вот запланирован, он карточку в массив добавит. И т.д.
Если пройдя по всем логически цепочкам у вас получается все изменения данных учесть в интерфейсе, значит вы на верном пути. Поздравляю.
Переносим в документацию.

Создаем раздел “Модели данных”. 
Описываем классы, которыми будем реализовать наши интерфейсы. Описываем какие действия выполняет тот или иной метод и для чего вообще класс.
Продолжение следует…

## Часть третья.

Теперь переходим к визуальной составляющей нашего проекта.
Здесь можно вспомнить начало разбора проекта Фильм (только начало, про разбор макета)
Ваша задача определить и выделить элементы отображения. При этом, помните о том, что отображение одного и того-же элемента может быть изменено просто путем использования разных темплейтов. Посмотрите в html у вас там уже созданы разные элементы сайта.
Посмотрите на макет. Выделите отдельные элементы. Запишите их.

Например Карточка товара, она по сути одна и та-же, только для вывода одних и тех-же данных используются разные темплейты. Вам понадобится класс, который возвращает разметку карточки. Что он должен для этого получить, как минимум данные одной карточки и темплейт, на основании которого нужно создать разметку.

Подумайте, что еще нужно для этого класса.
Вывод попапов. Сколько их, чем отличаются, что в них общего. Есть ли у них общий функционал. Если есть общий функционал, то его можно вынести в родительский класс. Не бойтесь заглядывать в проект “Оно тебе надо”. Он может натолкнуть вас на верные мысли. Так-же как и с данными, думайте сейчас не о коде, не о реализации, а пока только на уровне интерфейсах об объектах.

Запишите все объекты этого визуального слоя. Помните, что они получают данные для отображения, но не должны накапливать их (типа массив карточек)
Создайте в документации раздел Компоненты представления и запишите полученные классы туда. Напишите какой класс для чего. Если какой-то из классов будет родительским для других, опишите его первым.

Если класс будет базовым, т.е. сам по себе не используется для создания экземпляров и служит для всех компонентов данного типа родителем (например Component в “Оно тебе надо”) то его нужно выписать отдельно.

Все такие базовые классы, те, которые упоминались в начале и те что у вас появились здесь (если появились) вы описываете отдельно указывая, что данный класс является базовым для таких-то целей.

Посмотрите на описанные классы отображения. Постарайтесь логически представить их работу исходя из следующих предположений:
- если пользователь нажмет такую кнопку, то мы покажем такой компонент
- если изменятся такие данные, то мы покажем такой компонент или обновим
Описав все компоненты представления переходим к завершающему этапу. 
Нам нужно теперь увязать работу данных и работу компонентов представления.
Продолжение следует…

## Часть четвертая.

Наша задача связать работу с данными и работу с элементами разметки нашего сайта.
Делать мы это будем с использованием событийно-ориентированного подхода.
Что это значит?

Значит мы должны продумать все события, которые могут происходить на нашем сайте. Эти события могут генерироваться изменением данных или действием пользователей. Давайте по порядку.

События, которые возникают при изменении данных. При продумывании событий, сразу записывайте их. Какие это события? Все, связанные с изменением данных. Например, у нас есть уже описанные методы для хранимых нами данных карточек. Мы их даже описали ранее. Смотрите в свое описание моделей данных. Вы писали там методы, которые используются для изменения данных. Событий на самом деле меньше. Давайте подумаем с такой стороны, добавление новой карточки и удаление карточки, это разные события или одинаковые? С точки зрения действий, это два разных действия, с точки зрения событий, это одно и тоже событие - изменение списка наших карточек. При возникновении такого события нам нужно будет перерисовать наш список карточек, потому что он изменился. Даем этому событию название, например “items:changed”.

Добавляем в нашу документацию раздел “Описание событий” и записываем в него события связанные с изменением данных, или генерируемые моделями данных. Будет здорово, если вы сразу напишете, какие действия нужно будет выполнить при возникновении такого события. Например, при изменении списка карточек (я все еще на примере Место) необходимо перерисовать блок с карточками. Это поможет вам в дальнейшей работе, плюс при проектировании вы сверяете эти действия с вашими уже описанными моделями и макетом сайта, на котором отслеживаете логику работы приложения.

После этого нужно описать события генерируемые компонентами представления, или другими словами, события, которые возникают при каких-то действиях пользователя на нашем сайте. Например, клик в карточку. Это событие, его нужно будет как-то обработать. Дадим ему название, например “card:select”. Что у нас должно произойти при возникновении такого события? Открыться попап с картинкой карточки? А вот и нет. У нас должна выбранная карточка сохраниться в “Выбранную карточку” в модели данных. Мы ведь запланировали такое поле в классе с данными. А в классе с данными у вас, раз такое поле есть и метод есть для записи в него карточки, должно быть и событие, которое будет возникать при записи карточки в это поле. Проверили, что точно есть. Таким образом, проходимся по всему функционалу нашего сайт и выписываем все события, даем им названия и описываем на что эти события влияют. 
Описали все события, проверьте еще раз, что действия на разные события не повторяются (иначе возможно это одно и тоже по сути событие). Что весь функционал приложения описан этими событиями.

В документации следует немного дооформить данный блок, указав, что вы будете использовать эмиттер для работы с событиями. Вот как раз с этими самыми, которые только что описали.

Ну вот теперь то документация практически готова. Проверьте еще раз, что у вас в ней все на месте, что порядок описаний компонентов логически оправданный, т.е. сначала идут базовые, потом родители, потом потомки и т.п. Проверьте, что вся логика приложения укладывается в описанные вам схемы. Данные будут сохраняться куда нужно, при этом будут возникать события, которые приводят к изменению отображения (это описано в действиях, не в коде пока что).

У вас есть описание структуры, применяемого подхода, описание всех слоев. В каждом слое вы описали будущие классы и их структуру, назначение. Описывая события вы описали взаимодействие между частями приложения. Описывая данные вы создали в types/index.ts интерфесы используемых данных и моделей данных.
Это действительно не простая и не маленькая работа, но это уже половина работы по разработке приложения. Это сильно упростит вам саму разработку и избавит от большого количества переделываний в последствии. Отправляйте документацию на проверку, а мы готовимся к написанию кода.

## Часть пятая, заключительная.

Определите для себя порядок создания классов.
Например, сначала модели данных, потом представления. Или наоборот. Начинайте создавать классы. Начнем с данных.

У вас есть в описании классы, которые отвечают за хранение и обработку данных. Смотрите в ту логику, которую вы описали в документации. Начинайте описывать методы. Сначала можно описать все, что касается самих данных, а потом события. Можно писать сразу. У вас все это уже есть в документации. Написали метод, он получает параметры и изменяет хранимый массив. Написали код изменения данных. Дальше у вас написано, что это действие должно генерировать событие. Используйте метод emit вашего эмиттера, чтобы активировать событие. Напишите все классы и все методы из вашей документации. Если в процессе вы вдруг поняли, что забыли, например, внести сам экземпляр класса эмиттера в параметры конструктора модели данных, добавьте его в документацию и в код. Не забывайте, что документация должна соответствовать коду.

После этого можно реализовать слой представления. Схема та же. Описываете класс, не забывайте, что элементы разметки, с которыми вы работаете в классе, нужно найти и сохранить в поля класса в конструкторе, чтобы поиск элементов в DOM не повторялся в методах (если это не оправдано самим методом). Так-же генерируете события, там где это надо. Не забывайте, что при вызове события вы можете в событие передавать данные, вам это понадобится. Если возникли затруднения с оформлением вызова события, посмотрите в “Оно тебе надо”, постарайтесь понять, как активируются события и после одного раза больше вопросов с этим не будет.

После того, как вы создали весь слой представления начинается самый сложны этап. необходимо теперь увязать слои между собой. Для этого в index.ts начинаем описывать слушатели событий и колбэки для них. Все события у вас описаны в документации. Постарайтесь главным образом опираться на нее. Взяли событие, установили на него слушатель. Пишем обработчик. В обработчике могут использоваться как экземпляры классов с данными так и экземпляры классов представления. Используйте их методы, чтобы вызвать реакцию на событие. Для этого вам нужно будет вверху скрипта создать необходимые экземпляры. Постарайтесь разделить код логически. Отделяйте логические части пустыми строками. Чтобы вам было легче потом ориентироваться. Здесь создаем экземпляры моделей, пробел, здесь классы представления, пробел, вот вспомогательные, эмиттер, апи и т.д.

Когда все события описаны и слушатели назначены переходите к финальной части. Основной код выполняемый при загрузке приложения. Это, например, загрузка начальных данных с сервера. После загрузки нужно использовать метод класса с данными, чтобы начальные данные сохранить. Дальше у вас должно по схеме сработать все само. Т.е. сохранение начальных данных должно внутри класса вызвать генерацию события. На этом событии должен быть слушатель, в котором будет использование классов представления для отрисовки или изменения элементов странички. Получается, что вам достаточно только вызвать метод сохранения массива в классе с данными. Дальше будет работать событийная модель.

Искренне надеюсь, что это описание поможет вам приблизиться к решению проектной работы нашего модуля. Не бойтесь ошибиться, бойтесь ничего не делать. Ошибки в процессе обучения это нормально, именно благодаря им вы получаете опыт. Пробуйте, и пусть у вас обязательно все получится. 