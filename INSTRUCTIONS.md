## Для тех, кто еще не начал ничего сдавать и пока не понимает, что вообще сдавать и как вообще начать.

Перед нами большая проектная работа, которую надо сдать по результатам прохождения всего модуля. 
Что нужно обязательно учесть. Это ОДНА проектная работа. Она разделена на две части, но все равно это одна проектная работа и зачет по ней вы получите в конце 9-го спринта выполнив ее всю.

Первая часть сдается после 8-го спринта в соответствии с заданием в вашем тренажере. Это документация. Напомню, что UML схема НЕ обязательна, это опция, можете ее нарисовать, если есть желание. После того, как вы сдадите документацию, ревьювер вам напишет, что вы можете реализовывать функционал. Работа при этом НЕ БУДЕТ принята, так как это только часть Проектной Работы. Это нормально. Вы продолжаете изучать 9-й спринт и после этого продолжите сдавать проект в той-же самой форме. Если вы потратили 2 итерации, которые даются на сдачу документации, то вы все равно продолжаете изучение 9-го спринта и после него продолжаете сдавать ПР, но уже исправляя документацию и вместе с ней отправляя на проверку полностью все приложение.
Лучше сперва пройти теорию всего модуля и только потом, после просмотра всех видео и прочтения всех постов, после того, как вы разберетесь в том, как работает проект "Оно тебе надо", который дан вам в 9-м спринте, начинать выполнение проектной работы. С чего начать и как ее лучше выполнить.

Как говорится “Слона нужно есть по частям”
Предлагаю описать некоторые шаги, выполнение которых поможет вам пройти этот непростой этап.  Внутри треда я описал 5 основных шагов выполнения проектной работы, надеюсь, это поможет вам понять в каком направлении двигаться и с чего начинать.

## Часть первая.

Убедитесь, что у вас получен стартовый набор в вашей учетной записи на Гитхабе.
Скачайте и подключите коллекцию для программы Postman.

https://larek-api.nomoreparties.co/weblarek.postman.json

Убедитесь, что можете посмотреть примеры запросы и формат возвращаемых сервером данных.
По инструкции из задания к проектной работе создайте в корне своего проекта файл .env с константой, хранящей адрес сервера.
Скачайте из репозитория каноничное решение для проекта “Оно тебе надо”, который рассматривался в 9 спринте. Будем использовать его как пример для выполнения нашей работы.

Откройте макет проекта Веб-Ларек.
Посмотрите внимательно на макет и потом посмотрите на те данные, которые вам возвращает сервер на запросы (это в Постмане)
Сейчас ваша задача понять, какие данные нужно хранить в приложении и как эти данные могут изменяться, когда пользователь будет использовать наше приложение. Представьте все действия пользователя на сайте. Как при этих действиях будут изменяться данные. Например, если мы покупаем какой-то товар, то действие с данными будет такое: в корзине, которая представляет из себя массив объектов - товаров происходит добавление объекта в этот массив. И т.д.

Начните описывать Интерфейс для данных.
Т.е. вам нужно типизировать тот объект, который будет хранить эти данные.
Например карточка товара. (Чтобы понять какие типы у каких свойств в объектах с данными, подсматривайте в Постман)
Объекты для хранения данных не обязательно совпадают с теми, которые возвращает сервер. например, сервер не хранит и не отдает нам Корзину с нашими покупками.

Как пример, можно заглянуть и разобраться, как описаны данные в проекте “оно тебе надо”, например посмотрите интерфейс ILotItem
После написания Интерфейсов, посмотрите еще раз на макет и пройдитесь еще раз по всему пути, как пользователь. Смотрите при этом на описанные вами интерфейсы. Все ли данные вы учли в них.
Продолжение следует….

## Часть вторая.

Начинаем собирать нашу документацию.
Создайте в документации блок “Описание данных”
Перенесите в него уже написанные вами Интерфейсы, описывающие данные. напишите для чего они будут использоваться, что где хранится. Теперь наша задача продумать и описать модели данных.

Это Классы, которые будут отвечать за хранение данных. Может быть один класс, который будет хранить сразу все. Может быть несколько, например отдельно для товаров, отдельно для корзины и т.д.

Теперь возвращаемся к тем действиям, которые мы продумывали над нашими данными. Давайте их опишем. Заметьте, это пока еще не код. Только проектирование. Взяли конкретные данные. Посмотрим на примере нашего прошлого проекта Место.

У нас есть карточки. В первом шаге вы написали Интерфейс для данных. Там хранени данных карточки, ссылка, название, владелец, лайки и т.д. Вот теперь давайте думать о действиях. Согласно макету и нашим планам из прошлого шага мы можем что делать? Добавлять карточки. Начинаем описывать интерфейс для модели данных, которая будет хранить карточки и работать с ними. 

Что он хранит, массив карточек. Для карточки интерфейс уже описан в первом шаге, используем его для указания типа массива. Первое действие - добавление. Ага, значит добавим метод для добавления карточки. Это сеттер. Описали его в интерфейсе. Дальше, можно удалять карточки. Ок, добавили еще метод. Пока не касаемся реализации, просто описываем интерфейс.

Что еще? А изначально массив откуда берется? Мы его откуда-то получаем (все равно откуда) Добавили метод для добавления массива или инициализации. Здесь же еще нужно как-то хранить выбранную для чего-то карточку, например в Место это карточка для ее отображения в отдельном попапе. У вас карточка, открытая подробно в попапе.
И т.д.

После того, как все действия отражены в интефейсе, сделаем следующее. Пройдемся еще раз по всей логике по макету. Вот тут у нас должна отобразиться главная страница, что на ней, массив, он с сервера загружается. Есть у нас для этого запланированный метод, есть. Если пользователь нажмет плюсик, открывается попап новой карточки, данные меняются, нет еще. Потом после заполнения формы будет сабмит. При этом карточку надо будет после ответа сервера сохранить. Есть у нас для этого метод? Да вот запланирован, он карточку в массив добавит. И т.д.
Если пройдя по всем логически цепочкам у вас получается все изменения данных учесть в интерфейсе, значит вы на верном пути. Поздравляю.
Переносим в документацию.

Создаем раздел “Модели данных”. 
Описываем классы, которыми будем реализовать наши интерфейсы. Описываем какие действия выполняет тот или иной метод и для чего вообще класс.
Продолжение следует…

## Часть третья.

Теперь переходим к визуальной составляющей нашего проекта.
Здесь можно вспомнить начало разбора проекта Фильм (только начало, про разбор макета)
Ваша задача определить и выделить элементы отображения. При этом, помните о том, что отображение одного и того-же элемента может быть изменено просто путем использования разных темплейтов. Посмотрите в html у вас там уже созданы разные элементы сайта.
Посмотрите на макет. Выделите отдельные элементы. Запишите их.

Например Карточка товара, она по сути одна и та-же, только для вывода одних и тех-же данных используются разные темплейты. Вам понадобится класс, который возвращает разметку карточки. Что он должен для этого получить, как минимум данные одной карточки и темплейт, на основании которого нужно создать разметку.

Подумайте, что еще нужно для этого класса.
Вывод попапов. Сколько их, чем отличаются, что в них общего. Есть ли у них общий функционал. Если есть общий функционал, то его можно вынести в родительский класс. Не бойтесь заглядывать в проект “Оно тебе надо”. Он может натолкнуть вас на верные мысли. Так-же как и с данными, думайте сейчас не о коде, не о реализации, а пока только на уровне интерфейсах об объектах.

Запишите все объекты этого визуального слоя. Помните, что они получают данные для отображения, но не должны накапливать их (типа массив карточек)
Создайте в документации раздел Компоненты представления и запишите полученные классы туда. Напишите какой класс для чего. Если какой-то из классов будет родительским для других, опишите его первым.

Если класс будет базовым, т.е. сам по себе не используется для создания экземпляров и служит для всех компонентов данного типа родителем (например Component в “Оно тебе надо”) то его нужно выписать отдельно.

Все такие базовые классы, те, которые упоминались в начале и те что у вас появились здесь (если появились) вы описываете отдельно указывая, что данный класс является базовым для таких-то целей.

Посмотрите на описанные классы отображения. Постарайтесь логически представить их работу исходя из следующих предположений:
- если пользователь нажмет такую кнопку, то мы покажем такой компонент
- если изменятся такие данные, то мы покажем такой компонент или обновим
Описав все компоненты представления переходим к завершающему этапу. 
Нам нужно теперь увязать работу данных и работу компонентов представления.
Продолжение следует…

## Часть четвертая.

Наша задача связать работу с данными и работу с элементами разметки нашего сайта.
Делать мы это будем с использованием событийно-ориентированного подхода.
Что это значит?

Значит мы должны продумать все события, которые могут происходить на нашем сайте. Эти события могут генерироваться изменением данных или действием пользователей. Давайте по порядку.

События, которые возникают при изменении данных. При продумывании событий, сразу записывайте их. Какие это события? Все, связанные с изменением данных. Например, у нас есть уже описанные методы для хранимых нами данных карточек. Мы их даже описали ранее. Смотрите в свое описание моделей данных. Вы писали там методы, которые используются для изменения данных. Событий на самом деле меньше. Давайте подумаем с такой стороны, добавление новой карточки и удаление карточки, это разные события или одинаковые? С точки зрения действий, это два разных действия, с точки зрения событий, это одно и тоже событие - изменение списка наших карточек. При возникновении такого события нам нужно будет перерисовать наш список карточек, потому что он изменился. Даем этому событию название, например “items:changed”.

Добавляем в нашу документацию раздел “Описание событий” и записываем в него события связанные с изменением данных, или генерируемые моделями данных. Будет здорово, если вы сразу напишете, какие действия нужно будет выполнить при возникновении такого события. Например, при изменении списка карточек (я все еще на примере Место) необходимо перерисовать блок с карточками. Это поможет вам в дальнейшей работе, плюс при проектировании вы сверяете эти действия с вашими уже описанными моделями и макетом сайта, на котором отслеживаете логику работы приложения.

После этого нужно описать события генерируемые компонентами представления, или другими словами, события, которые возникают при каких-то действиях пользователя на нашем сайте. Например, клик в карточку. Это событие, его нужно будет как-то обработать. Дадим ему название, например “card:select”. Что у нас должно произойти при возникновении такого события? Открыться попап с картинкой карточки? А вот и нет. У нас должна выбранная карточка сохраниться в “Выбранную карточку” в модели данных. Мы ведь запланировали такое поле в классе с данными. А в классе с данными у вас, раз такое поле есть и метод есть для записи в него карточки, должно быть и событие, которое будет возникать при записи карточки в это поле. Проверили, что точно есть. Таким образом, проходимся по всему функционалу нашего сайт и выписываем все события, даем им названия и описываем на что эти события влияют. 
Описали все события, проверьте еще раз, что действия на разные события не повторяются (иначе возможно это одно и тоже по сути событие). Что весь функционал приложения описан этими событиями.

В документации следует немного дооформить данный блок, указав, что вы будете использовать эмиттер для работы с событиями. Вот как раз с этими самыми, которые только что описали.

Ну вот теперь то документация практически готова. Проверьте еще раз, что у вас в ней все на месте, что порядок описаний компонентов логически оправданный, т.е. сначала идут базовые, потом родители, потом потомки и т.п. Проверьте, что вся логика приложения укладывается в описанные вам схемы. Данные будут сохраняться куда нужно, при этом будут возникать события, которые приводят к изменению отображения (это описано в действиях, не в коде пока что).

У вас есть описание структуры, применяемого подхода, описание всех слоев. В каждом слое вы описали будущие классы и их структуру, назначение. Описывая события вы описали взаимодействие между частями приложения. Описывая данные вы создали в types/index.ts интерфесы используемых данных и моделей данных.
Это действительно не простая и не маленькая работа, но это уже половина работы по разработке приложения. Это сильно упростит вам саму разработку и избавит от большого количества переделываний в последствии. Отправляйте документацию на проверку, а мы готовимся к написанию кода.

## Часть пятая, заключительная.

Определите для себя порядок создания классов.
Например, сначала модели данных, потом представления. Или наоборот. Начинайте создавать классы. Начнем с данных.

У вас есть в описании классы, которые отвечают за хранение и обработку данных. Смотрите в ту логику, которую вы описали в документации. Начинайте описывать методы. Сначала можно описать все, что касается самих данных, а потом события. Можно писать сразу. У вас все это уже есть в документации. Написали метод, он получает параметры и изменяет хранимый массив. Написали код изменения данных. Дальше у вас написано, что это действие должно генерировать событие. Используйте метод emit вашего эмиттера, чтобы активировать событие. Напишите все классы и все методы из вашей документации. Если в процессе вы вдруг поняли, что забыли, например, внести сам экземпляр класса эмиттера в параметры конструктора модели данных, добавьте его в документацию и в код. Не забывайте, что документация должна соответствовать коду.

После этого можно реализовать слой представления. Схема та же. Описываете класс, не забывайте, что элементы разметки, с которыми вы работаете в классе, нужно найти и сохранить в поля класса в конструкторе, чтобы поиск элементов в DOM не повторялся в методах (если это не оправдано самим методом). Так-же генерируете события, там где это надо. Не забывайте, что при вызове события вы можете в событие передавать данные, вам это понадобится. Если возникли затруднения с оформлением вызова события, посмотрите в “Оно тебе надо”, постарайтесь понять, как активируются события и после одного раза больше вопросов с этим не будет.

После того, как вы создали весь слой представления начинается самый сложны этап. необходимо теперь увязать слои между собой. Для этого в index.ts начинаем описывать слушатели событий и колбэки для них. Все события у вас описаны в документации. Постарайтесь главным образом опираться на нее. Взяли событие, установили на него слушатель. Пишем обработчик. В обработчике могут использоваться как экземпляры классов с данными так и экземпляры классов представления. Используйте их методы, чтобы вызвать реакцию на событие. Для этого вам нужно будет вверху скрипта создать необходимые экземпляры. Постарайтесь разделить код логически. Отделяйте логические части пустыми строками. Чтобы вам было легче потом ориентироваться. Здесь создаем экземпляры моделей, пробел, здесь классы представления, пробел, вот вспомогательные, эмиттер, апи и т.д.

Когда все события описаны и слушатели назначены переходите к финальной части. Основной код выполняемый при загрузке приложения. Это, например, загрузка начальных данных с сервера. После загрузки нужно использовать метод класса с данными, чтобы начальные данные сохранить. Дальше у вас должно по схеме сработать все само. Т.е. сохранение начальных данных должно внутри класса вызвать генерацию события. На этом событии должен быть слушатель, в котором будет использование классов представления для отрисовки или изменения элементов странички. Получается, что вам достаточно только вызвать метод сохранения массива в классе с данными. Дальше будет работать событийная модель.

Искренне надеюсь, что это описание поможет вам приблизиться к решению проектной работы нашего модуля. Не бойтесь ошибиться, бойтесь ничего не делать. Ошибки в процессе обучения это нормально, именно благодаря им вы получаете опыт. Пробуйте, и пусть у вас обязательно все получится. 

# Дополнительные материалы и ссылки
## Снова всем привет. 
```
Для тех, кто еще читает теорию 8-го спринта и не совсем понимает, что со всем этим делать.

Вот вы читаете теорию 8-го спринта, узнаете об объектах и классах, выполняете задания в тренажере, но как правило, вопросов обо всех этих классах становится все больше и больше. Чтобы немного помочь, решил записать небольшой сериал (больше 2 серий это же уже сериал :) ) про разработку небольшого приложения. Приложение это классическая Тудушка. Т.е. список дел. При разработке постараюсь пройти от самого простого, вывода списка с помощью ванильного JS до реализации всего приложения на ООП в парадигме MVP и в конечном счете перевести все на СОП. Можно начинать смотреть до прохождения 9-го спринта. Дойдя до MVP взять небольшую паузу и дочитать тренажер. Но лучше сперва прочитать про паттерны проектирования, чтобы при переходе на классы и слои MVP было понятнее зачем мы это делаем. Замечания и вопросы на очередной Q&A приветствуются. Все ролики будут собраны в одном плэйлисте для удобства просмотра. Под каждым роликом в описании есть ссылка, по которой можно скачать исходный код, как самый стартовый, с версткой, так и тот код, который был написан в процессе записи ролика. https://www.youtube.com/playlist?list=PLDc4FQSB7ty_LHvwh-Lgfn3jgeNS_qL-z
Обратите внимание: Это не пример выполнения проектной работы. Это пример работы с разными классами и слоями приложения. Я постарался показать, как от обычного JS мы пришли к классам и слоям и чем это все было вызвано. Т.е. это поддержка вас просто для понимания теории модуля. Для лучшего понимания требований ПР будет следующий ролик.

Для подстраховки, в связи с проблемами на ютуб, выложил ролики так-же на рутубе. они доступны по ссылкам:
1. https://rutube.ru/video/private/6185ceae0db2bee838acbc89215807d0/?p=SC6atc0ifzwv9e7RHwhHlg
2. https://rutube.ru/video/private/f41595efcb203f589ebee95452fd188d/?p=8Y2yh74prMt-MdBwqU3pew
3. https://rutube.ru/video/private/4236f6608def3a6e02ccdb00f7285675/?p=6eg4smHqN3qMIuiryK4lqg
4. https://rutube.ru/video/private/1ab80a61c0ba5c9f06861b98fb406f82/?p=OLor8g3jO2VRDF4Rz3wX8g
5. https://rutube.ru/video/private/83cd294d317104dcf3c7e47719793640/?p=h6Kapx5MbrygxCCMYzcgBA
6. https://rutube.ru/video/private/9e0481b73a534135a5ed7d719af59745/?p=UF6N2r8bQ_i6mEGz4v6u_A
7. https://rutube.ru/video/private/070d20251b6d0effb1803d329dd88a47/?p=nTLCi9Heowcz2m2uYV4Y2g
8. https://rutube.ru/video/private/2b21afea04a078442102bf1713593ac4/?p=LeNhkpC6Nkaa-t0Bhv_NuA
```
## Всем привет. Важно для выполнения ПР
```
Всем привет. Так как темп прохождения спринта у каждого свой, выкладываю здесь дополнительную информацию, важную для выполнения проектной работы.
Важно!!!
Проверьте какой сервер mpn у вас подключен. Сделать это можно командой
npm config get registry
Если у вас подключен сервер ЯндексПрактикума, то нужно переключиться на дефолтный. В противном случае у вас не получится работать с проектом. Как это сделать. Выполните команду
npm set registry https://registry.npmjs.org/
Про сдачу проектной работы:
Обратите внимание, что выполнение проектной работы у вас разбито на две части. Но и для написания документации нужно разобрать макет и понимать логику работы приложения, а значит информация в данном посте будет жизненно нужна. Рекомендую пройти сначала весь модуль, а только потом приниматься за проектную работу. Проектная работа, которую вы видите на 8 спринте не является блокирующей, т.е. можно ее пропустить и заполнив форму обратной связи изучать 9 спринт. После того, как вы разберете проект "Оно тебе надо", который дается вам на 9-м спринте, можно приступать к написанию архитектуры своего проекта и его сдаче.

В открытой карточке товара у вас в макете два разных написания текста на кнопке приобретения. Это недочет макета. Можете сделать любой из вариантов, какой вам больше придется по вкусу.  Обратите внимание, что надпись "В корзину" - это не переход в корзину, а команда добавить товар в корзину, т.е. купить.
В макете не отрисована карточка с товаром, который уже есть в корзине. Предполагается, что в карточке, которая уже была добавлена в корзину, кнопка покупки будет изменена на кнопку удаления товара из корзины. От вас будет принята любая реализация, главное условие - товар не должен добавляться в корзину дважды.  Т.е. если товар уже есть в корзине, кнопка покупки должна измениться на "Удалить из корзины" или просто быть заблокированной.
Неявное условие по поведению приложения после добавления товара в корзину. Вы можете закрыть попап с товаром, а можете оставить его открытым. В случае, если карточка товара остается открытой, не забудьте что-то сделать с кнопкой покупки. Ее поведение должно соответствовать тому, которое вы определили для себя в пункте 2
Бесценный товар. Он не имеет цены, т.е. его цена null. По макету, такой товар тоже можно купить. Тогда принимаем его цену за 0 (ноль) при расчете общей стоимости корзины и при отправке запроса на сервер исключаем его из массива товаров. По здравому смыслу, такой товар не может быть куплен, так как бесценен и в таком товаре кнопка покупки должна быть заблокирована (неактивна).  Примечание: Если в карточке купленного товара будете деактивировать кнопку покупки вместо изменения ее надписи и функционала, то возможна путаница, кнопка неактивная так как товар уже в корзине или он бесценен. Будет здорово, если у вас это поведение кнопки в разных случаях будет отличаться, т.е. в первом изменяться на "Удалить из корзины", во втором деактивация. Но ревью примет любой ваш вариант.
Из-за этого бесценного товара может возникнуть ситуация, когда в корзине будет только один бесценный товар. Тогда можно оформить заказ, но при его отправке, товар будет удален из массива и на сервер отправится пустой массив, что приведет к ошибке. Рекомендую выполнять проверку не на пустую корзину, а на стоимость корзины. Это не сложно, но тогда, если в корзине только один бесценный товар, то кнопка оформления будет недоступна.

Для работы с коллекцией в Постмане https://youtu.be/3od9WRKud-w

Для взаимодействия с сервером.

Несколько важных моментов.

При отправке запроса на сервер для оформления заказа текстовое значение формы оплаты не играет никакой роли. Вы можете записать любой текст, который захотите. Сервер не примет только пустое значение, все остальное на ваш выбор “cash/card” или “нал/безнал” все равно.
При получении с сервера картинок товара, они будут отличаться от изображения их в макете. Мы про это знаем, ревью тоже. Это допустимо.
Обратите внимание, что у вас в заготовке уже присутствуют константы. Две константы для определения основного адреса для запросов на сервер.

export const API_URL = `${process.env.API_ORIGIN}/api/weblarek`;
export const CDN_URL = `${process.env.API_ORIGIN}/content/weblarek`;

API_URL - используется для запросов данных о товарах и отправки заказа
CDN_URL - используется для формирования адреса картинки в товаре.

Так-же формирование адреса с использованием констант показано в ролике про коллекцию для Постмана. Посмотрите его обязательно.
```
## Для тех кто начинает сдавать документацию. Обратите внимание.
```
Документация это не модуль TS. Не нужно из документации экспортировать интерфейсы. Если вы копируете код из модуля, уберите хотя бы слово export
У вас в задании написано, что нужно написать интерфейсы. Я вам очень рекомендую, написать только интерфейсы для данных, с которыми вы будете работать в приложении. Не нужно писать интерфейсы для всех классов. Во-первых, интерфейсы для классов не пишутся практически никогда, интерфейсы мы пишем для объектов, которые эти классы создают. Во-вторых, на текущем этапе обучения это очень сложно сделать корректно, вы будете постоянно пытаться описать не объект, а сам класс, не нужно этого делать. Просто пропустите, ревью это понимает и не требует этих интерфейсов. А вот сами Классы…. Об этом дальше.
В документации должны быть описаны КЛАССЫ. Не интерфейсы классов, а сами классы. Описаны, не значит написан их код, они должны быть описаны текстом. Напишите название класса, его назначение и зону ответственности.  Опишите конструктор класса, какие параметры он принимает. Затем поля класса. Какие данные они будут хранить и их предназначение. Для Моделей надо описать каждое поле класса. Для представления можно сократить, просто перечислив элементы разметки, которые будут сохранены в полях. Дальше идут методы класса. Каждый метод должен быть описан с учетом данных которые он принимает и возвращает. Назначение метода. Если это сеттер (в представлении), то можно тоже не описывать каждый, а просто написать что для следующих данных будут написаны сеттер и указать тип данных, который описывает объект, в котором вы будете данные в класс для рендера передавать.

Обязательно напишите про парадигму, которую будете применять. Если это MVP то как минимум три слоя должно быть выделено в документации. Вот прямо отдельно "СЛОЙ МОДЕЛЬ" и дальше классы модели. "СЛОЙ ПРЕДСТАВЛЕНИЯ" и дальше классы представления, "СЛОЙ ПРЕЗЕНТЕРА" и вот тут пишите, код презентера не будет выделен в отдельный класс, а будет размещен в основном скрипте приложения. (Если конечно вы не решите отдельные классы делать)

При использовании событийно-ориентированного подхода напишите об этом и укажите, какие события будете использовать. Будет очень хорошо, если приведете хотя бы один пример взаимодействия. Что в этом примере должно быть главным. Нужно показать, что вы понимаете как будет вся схема работать. Что у вас по шагам будет так:
1. Вью реагирует на действие пользователя и генерирует событие.
2. Презентер обрабатывает событие и вызывает метод модели для изменения данных
3. Модель изменяет данные и генерирует событие
4. Презентер обрабатывает событие и вызывает рендер Вьюхи передавая в нее данные из модели
5. Вью перерисовывается отображая обновленные данные.

Примерно так, только конкретную ситуацию (НЕ МОЙ ТЕКСТ) Возьмите конкретную ситуацию из проекта. Любую, любой клик пользователя куда-то и по пунктам прямо Первый пункт, какой именно класс Вью реагирует на пользователя, какое конкретно событие будет сгенерировано. 2. Какой метод модели вызовет презентер. 3. В каком поле класса изменятся данные в модели и какое конкретно событие будет сгенерировано 4. Каким методом презентер запросит данные из модели и в какой класс Вью он их передаст в рендер 5. Какой класс вью перерисуется.

Класс - это инструмент для создания объектов. Если у вас уже есть объект, вам не нужен класс для его создания. Он уже объект. Класс для создания объекта товара абсолютно бессмысленен. от слова СОВСЕМ. Вам не нужно создавать объект - товар. Он уже и так объект.

Модальные окна. Класс для реализации модального окна ОДИН. У него нет подчиненных. Он никак не расширяется. Согласно вашей верстке, это объект, который отображает внутри себя любую разметку, которую ему передадут в контент. Все остальные классы только генерируют свой контент и им все равно, куда его потом выведут, хоть в модалку хоть на страницу. Не нужно в других классах писать что они реализуют модальные окна или наследуются от модального окна, это не корректно и не соответствует верстке вашего приложения.
```
## Для тех, кто еще не начал ничего сдавать и пока не понимает, что вообще сдавать и как вообще начать.
```
Перед нами большая проектная работа, которую надо сдать по результатам прохождения всего модуля. 
Что нужно обязательно учесть. Это ОДНА проектная работа. Она разделена на две части, но все равно это одна проектная работа и зачет по ней вы получите в конце 9-го спринта выполнив ее всю.
Первая часть сдается после 8-го спринта в соответствии с заданием в вашем тренажере. Это документация. Напомню, что UML схема НЕ обязательна, это опция, можете ее нарисовать, если есть желание. После того, как вы сдадите документацию, ревьювер вам напишет, что вы можете реализовывать функционал. Работа при этом НЕ БУДЕТ принята, так как это только часть Проектной Работы. Это нормально. Вы продолжаете изучать 9-й спринт и после этого продолжите сдавать проект в той-же самой форме. Если вы потратили 2 итерации, которые даются на сдачу документации, то вы все равно продолжаете изучение 9-го спринта и после него продолжаете сдавать ПР, но уже исправляя документацию и вместе с ней отправляя на проверку полностью все приложение.
Лучше сперва пройти теорию всего модуля и только потом, после просмотра всех видео и прочтения всех постов, после того, как вы разберетесь в том, как работает проект "Оно тебе надо", который дан вам в 9-м спринте, начинать выполнение проектной работы. С чего начать и как ее лучше выполнить.

Как говорится “Слона нужно есть по частям”
Предлагаю описать некоторые шаги, выполнение которых поможет вам пройти этот непростой этап.  Внутри треда я описал 5 основных шагов выполнения проектной работы, надеюсь, это поможет вам понять в каком направлении двигаться и с чего начинать.
```
## Решил записать вам еще один видосик, а то как-то мало их. Хотел маленький, но не получилось. А перезаписывать уже не получается, так что, как есть.
```
https://youtu.be/mIpfLAIbsBU

Про что он?
Про слои.
Про MVP, зачем, а главное как. Как создаются Модели, как понять, какие Вью у вас будут и как выделить их в разметке. Как они должны работать и как настроить взаимодействие между ними.

Для кого?
Для тех кто еще только в процессе осознания предстоящей проектной работы и хотелось бы весь этот MVP на чем-то попроще потрогать.
```
